# SMART ER - IoT Automized Architecture
![IoT_schema.pdf](https://github.com/ingalessandrobaldo/IoTProject/files/5672352/IoT_schema.pdf)

SMART ER is an IoT microservice oriented platform, which provides for a better management and processing of the patients flows. Nowadays, the long waiting times in an Emergency Room of an hospital represents a crucial aspect for both the patient’s and the hospital’s sides. On the one hand, hours and hours of waiting could make the patients’ health get worse, without creating the conditions for the hospital to intervene quickly. On the other hand, the old-style management of the queues represents a threat for the hospital itself.
The architecture, thus, offers a smart way to keep track and monitor the vital parameters of each patient after the Triage phase. At each patient three sensors are assigned, to check the basic health status: a connected smart sensor to measure the blood pressure, a glucometer to analyze glycemic values and a smart pulsossimeter for both heart rate and oxygenation blood level. These sensors are provided by the iHealth company and so data are stored in a secure way in their own cloud platform and retrieved in real-time by the hospital.
The second main task this system does, deals with a dynamic processing of the patients, based mainly on the evolutions of their health since they entered the Emergency Room. In this way, everyone is monitored and positioned correctly by the system, avoiding the worst-case scenario of death in the ER, caused by an a-priori unpredicted worsening of the conditions
In addition, several small microservices supplement the overall architecture. Indeed, the hospital can be provided for historical and real-time statistics, as well as user-friendly interfaces such as two distinct Telegram Bots

## Registry Catalog
The Registry Catalog represents the entity coordinator of the architecture. Its behavior emulates a “rake”: once a entity pushes its own data to it, the Catalog provides for a continuous update of the system, informing the main components about the addressability of the others involved in the processes, at regular time intervals. It follows a RESTful paradigm, using the following HTTP methods:
- <strong>POST</strong> method: it receives the initial configuration at the start of each entity, differentiating them according to their main characterization. Some basic information it collects are: IP address, port number and, eventually, MQTT topics. Through JSON-based responses, it allows the entity to join the architecture and know about the other active microservices. A general response contains at least a list of IP address-port couples of the other entities. For MQTT-based microservices, topics are sent too
- <strong>PUT</strong> and <strong>DELETE</strong> methods: the Catalog here is contacted to manage the state of the sensors, updating a triplet (pressure, glucose and heart) of sensors respectively if they are borrowed by a patient or released
An SQL-like DB architecture permits to reach these scopes, supporting dynamically more data- formats, without compromising the data themselves. The library adopted is the <strong>mysql.connector</strong> library by MySQL, while <strong>phpMyAdmin</strong> was chosen as the reference application.
The main difficulty dealt with the coordination of active and passive tasks and after some empirical analyses on traffic data, the best solution was choosing as a correct update interval a value of 3s. In this way, each microservice is informed if any other useful microservice left the system (or joined the system) almost in real-time, without causing an overloading at the Catalog side

## iHealth Adapter
The iHealth Adapter has the main function of retrieving data from the sensors. It communicates with three emulated sensors (Pressure, Glucometer and Pulsossimeter), which generate random data once they are asked to do it. In order to make the measurement more realistic, only the first one of each patient was conceived to be completely random. Indeed, starting from the second measurement, each value is derived as a 20% deviation from the previous one. In this way, an eventual worsening of the condition would be gradual in the time scale. Despite that, also a fast aggravation case is managed by the emulation: in fact each sensor can send a truly random generation, if the lower (or upper) threshold would be overwhelmed by the previous rule.
The iHealth Adapter is characterized by a RESTful structure, exposing the following methods: 
- <strong>POST</strong> method, where it receives the updates from the Registry Catalog
- <strong>GET</strong> method, characterizing the communication channel between the Queue Processing server and the sensors, in order to link the basic patients’ information with the measurements from the assigned sensors. Each GET request it receives, is characterized by a triple id, corresponding to the unique triplet of sensors’ ids assigned to the patient for which it retrieves data.
The iHealth Adapter, according to the gravity of each patient, is contacted at regular intervals, to keep the measurements and the patient’s health status updated
In the iHealth Adapter, we thought to implement an API-based structure, through the <strong>Flask</strong> routing library. The process is a 3-way authentication procedure. The first step deals with the authorization: the client presents to the server its session parameters (client_id, redirect_uri, on which the server sends the responses). Through a callback mechanism, the authentication step is performed. A unique expiring code is sent to the client, which routes its request to the ihealth- api server. Thus, it obtains two expiring tokens which allow for a short period of time to request the data from the cloud. As last, the retrieve of data is performed to a final request. The data obtained are JSON-formatted. A cons of this architecture is that its fill automation is very though. The translation to a cherrypie-like structure is not possible. Indeed, this kind of APIs are more feasible in a web-like context.

## Database Server
The Database Server’s function is to store the data coming from both sensors and the hospital application. It is organized in two main tables:
- <strong>PatientsData</strong>: containing registry patient information and the unique ids of the sensors assigned during the triage procedure
- <strong>DataSensors</strong>: where data from sensors are collected and are identified by the unique ids of the sensors and a timestamp reference, to allow to track an historical trend for each patient
The Database, as in the case of the Catalog, exploits the connectors provided by <strong>mysql</strong>, allowing a good scaling also in case of multiple SELECT/INSERT/UPDATE statements. The Database at every restart, truncates the tables, in order to empty them from old useless data
To guarantee an intercommunication with the other entities, it is characterized by the REST APIs, exposing the following methods:
- <strong>POST</strong> method, where it receives the updates from the Registry Catalog. During its configuration phase at the start, the Database Server communicates to the Catalog the DB structure itself, as an own backup in case of failure

- <strong>GET</strong> method: it is the communication channel with the processing data servers. It offers two data categories:
- Raw data to process (used by the Queue Processing Server): the different queries only organize the data in a dictionary-like structure
- Categorized data (used by the Statistic Processing Server): the SQL queries already acts as a filter on data. In this way part the complexity is divided between the two servers
- <strong>PUT</strong> method, which allows the INSERT/UPDATE statements of new incoming data. The integrity of the data is guaranteed by accurate checks on the correctness
- <strong>DELETE</strong> method, to manage the discharges of the patients. The patient is not really deleted from the table, but it is marked with a flag field. This is done to guarantee that the hospital can process some statistics based on the past flows

## Queue Processing Server
It is a RESTful and MQTT-like server, through which the data pass in multiple directions: from the client-side (hospital) to the server-side (database) and from the server-side (database) to the users (patients in the triage room).
Following, the main data flows:
- <strong>From</strong> the Telegram Hospital Interface <strong>to</strong> the Database Server: the first half of this communication, due to its impulsive/event-driven characterization, is done through a Publish- Subscribe paradigm exploiting the MQTT protocol. The Queue Server subscribes to the topic on which the Telegram Bot Server publishes the information of new clients. Then, the Queue Server adopts some HTTP request mechanisms to complete the data flow until the DB Server.
Firstly, a PUT request is sent to the Database, to store the received data.
Sequentially, the Queue Server retrieves data from the sensors of the current patient, sending a GET HTTP request to the iHealth Adapter. As a last step, it contacts similarly the Time Shift Server, to set a “patient’s clock” and to schedule the next measurements, according to its health status gravity
- <strong>From</strong> the Database Server <strong>to</strong> Public Telegram Channel: the first communication happens through a GET request, while the second part exploits again a Publish mechanism, pushing the data once they have been processed. In the middle, the core operations to allow a correct processing are the following:
    - Starting from a raw list of patients currently in the structure, patients within the same code are compared between each other according to their last measured health parameters and a ‘gravity score’ is assigned to them.A ranking is created, to dynamically position the patients inside the queue. In case two or more patients reached the same score, the ranking would consider also the time they have been spending in the hospital structure since they registered at the triage
    - Then, for each patient, an historical trend is considered, keeping track of all the measurements since he/she entered the structure. If a deterioration of the conditions happened during that time, if possible, the system gives the patient a more severe code, in order to fasten him/her processing, updating also the frequency of its scheduled measurements
As a last task, this server manages the discharging of the patients, using some random criteria. A coherent random number N is drawn and the first N patients are discharged, as they were really processed by the Hospital

## Statistic Processing Server
It is a RESTful server, used to calculate statistics on the patients and offer them as an independent service. It obtains data from the DB server, which have been already structured to facilitate the extraction of the useful statistics. At the current state the available statistics are:
### Historical statistics
- Patients by <strong>gender</strong>
- Patients by <strong>age</strong>
- Patients by <strong>code</strong>
- Patients by <strong>unit</strong>
- Number of patients who suffer from obesity
### Real-time statistics
- Real-time <strong>unit</strong> occupation
- Real-time <strong>code</strong> distribution
- Real-time <strong>vital parameters</strong> trends of the hosted patients (maximum and minimum
pressure, heart rate, blood oxygenation and glucose level)
However, other forms of useful data can be thought
The update of the statistics is done just before the publications of them is requested by the Hospital Bot Interface on Telegram. The statistics are thus represented in a graphical form created with the external tool matplotlib.pyplot library. Also in this case, other forms of representation can be thought
## Time Shift Server
It is a RESTful scheduler, which is activated only by the Queue Processing Server when a new patient has been registered. Subsequently, the Time Shift’s main operation deals with sending some timely alerts to the Queue Processing Server itself, in order to maintain the programmed frequency of measurements. It exposes the following HTTP methods:
- <strong>POST</strong> method, where it receives the updates from the Registry Catalog
- <strong>PUT</strong> method: used to set a new scheduling for a patient. A dictionary-like structure is used to
guarantee low complexity in the access of the structure. The dictionary is developed over a multi-level hierarchy. The first set of keys divides the patients in their respective triage codes. Under each one of these keys, there exists a list of dictionaries (one for each scheduled patient), characterized by the triplet of sensors assigned to the patient and a timestamp field, referring to the last registered measurement. The TimeShift every second will check for each patient, if a new measurement is needed. Code 2 patients will be checked every 60 seconds, code 3 ones every 240, code 4 every 480, code 5 every 960. These values are coherent to the time tables of the Italian Sanity System (ISS). Indeed, taking into account for example a patient of code 3, as stated by the ISS, its discharge should be managed within 1 hour. In this way, in this range a total amount of 15 measurements would be performed. The same proportion is present in the other codes.
- <strong>DELETE</strong> method: to update the scheduling table once a patient is discharged Even in this case, the responses are JSON-formatted

## Telegram Bot (TriageBot) Interface and Server
It represents the input interface, thought to be used by the Hospital staff, to fasten and scale better the Triage procedure. The application provides for two distinct tools:
- <strong>Insertion</strong> of new patient’s data: in this procedure, an easy and quick sequence of operations allows the acceptance of new incoming patients. Registry personal information are asked and the system ensure the correctness of the inserted data. At the end of the procedure, the system itself provides for assigning a triplet of available sensors, in order to keep track of the basic vital parameters. This is also done thanks to the continuous updates received by the server behind from the Catalog. Once a triplet of sensors is assigned to a new patient, the Telegram Server sends automatically a request to the Catalog. In the case of lack of available sensors, the application itself will inform the user about the current unavailability, not allowing any kind of insertion until some sensors are released
- Request of historical <strong>statistic</strong>s: this procedure allows to keep track of the historical statistics of the structure. In this way, the hospital structure could improve different areas of the Hospital, as well as strengthen some units, where the numbers of incoming patients are high
- Request of <strong>real-time statistics</strong>: an easy way to check the current units’ occupation and how are distributed the patients according to their gravity. Moreover, some trends are developed to monitor in real-time vital parameters of each patient into the structure

The Telegram Server collects several programming paradigms inside, as well as libraries:


- the <strong>Bot Interface</strong> was developed through the Telepot Library. Inside some particular functions are remarkable, such as InlineKeyboardMarkup and ReplyKeyboardMarkup, with the relative buttons. This choice gave to the interface a modern aspect and allowed to support an <strong>Event Driven Architecture</strong>, to better adapt it to the users’ actions. Moreover, through a dictionary-like structure, the Bot is able to manage multiple interactions from multiple different users, parallelizing the jobs for each one. This choice was the best compromise between an efficient, with low-complexity method, considering that a Multithreading classical approach would have not been compatible with the Telegram APIs
- a <strong>RESTful</strong> construction, providing the POST HTTP method, fundamentally useful for the real-time update with the Catalog
- the <strong>MQTT</strong> inheritance, allowing the push of the data once inserted by the Hospital staff
## Telegram Channel (Hospital Channel) Interface
This represents an hospital channel, in which the patients can check their position in the queue. The users have only reading permissions and they can consult the state of the Queue in real time, referring to their own “patient code” assigned at the end of the Triage procedure. The server behind this bot supports both <strong>REST</strong> and <strong>MQTT</strong> APIs. It acts as a subscriber of the Queue Processing Server, which regularly publishes the processed queue. Before the raw received queue is notified to all the users, the Telegram Channel performs some text editing, to guarantee a more human-readable queue
